#lang rhombus/static/and_meta
import:
  lib("esterel/kernel.rkt"):
    expose #{present?}
    expose #{react!}
    expose #{exit-trap}
    expose #{signal-name}
    expose #{signal-index}
    expose #{esterel?}
    expose #{in-esterel?}
    expose #{signal?}
    expose #{signal-value}
    expose #{debug-when-must}
    expose #{signal-combine}
    expose #{trap?}
    expose emit as kernel_emit
    expose pause as kernel_pause
  lib("esterel/private/kernel.rkt") as pkernel:
    expose #{mk-signal/args}
    expose #{esterel/proc}
    expose #{par/proc}
    expose #{with-trap/proc}
    expose #{run-and-kill-signals!}
    expose #{no-init}
  lib("syntax/location.rkt"):
    expose #{quote-srcloc}
  lib("racket/set.rkt") as racketset
  lib("racket/base.rkt") meta

export:
  def_signal
  esterel
  ¿
  |||
  par
  emit
  react
  with_trap
  exit_trap
  with_signal
  pause
  signal_name
  signal_index
  is_esterel
  in_esterel
  signal_value
  suspend
  is_trap
  is_present

meta syntax_class SignalOptions
| '~memoryless ~init $init_expr ~combine $combine_expr':
    field init = init_expr
    field combine = combine_expr
    field memoryless = #true
| '~init $init_expr ~combine $combine_expr':
    field init = init_expr
    field combine = combine_expr
    field memoryless = #false
| '~combine $combine_expr':
    field init = '#{no-init}'
    field combine = combine_expr
    field memoryless = #false
| '~single':
    field init = '#{no-init}'
    field combine = '#'single'
    field memoryless = #false

meta syntax_class SignalDefinition
| '{$id_exprs, ...} $(options::SignalOptions)':
    def init_name_we_made_up = base.gensym()
    def combine_name_we_made_up = base.gensym()
    field [id, ...] = [id_exprs, ...]
    field init_def = 'def $init_name_we_made_up = $options.init'
    field combine_def = 'def $combine_name_we_made_up = $options.combine'
    field [init, ...] = [id_exprs, ...].map(fun (_): init_name_we_made_up)
    field [combine, ...] = [id_exprs, ...].map(fun(_): combine_name_we_made_up)
    field [memoryless, ...] = [id_exprs, ...].map(fun(_): options.memoryless)
| '$id_expr $(options::SignalOptions)':
    field [id, ...] = [id_expr]
    field init_def = '#false'
    field combine_def = '#false'
    field [init, ...] = [options.init]
    field [combine, ...] = [options.combine]
    field [memoryless, ...] = [options.memoryless]
| '$id_expr':
    field [id, ...] = [id_expr]
    field init_def = '#false'
    field combine_def = '#false'
    field [init, ...] = ['#{no-init}']
    field [combine, ...] = [#false]
    field [memoryless, ...] = [#false]

defn.macro 'def_signal [$(signal_definition :: SignalDefinition), ...]':
  def [[srclocs, ...], ...] = [[expr_meta.pack_s_exp(['#{quote-srcloc}', signal_definition.id]), ...], ...]
  'def [[$signal_definition.id, ...], ...] = \
   block:
        $signal_definition.init_def; ...
        $signal_definition.combine_def; ...
        [[#{mk-signal/args}(#'$signal_definition.id, $signal_definition.init, $signal_definition.combine, $srclocs, $signal_definition.memoryless), ...], ...]'


expr.macro 'with_signal [$(signal_definition :: SignalDefinition), ...]:
              $body':
  def [[srclocs, ...], ...] = [[expr_meta.pack_s_exp(['#{quote-srcloc}', signal_definition.id]), ...], ...]
  'block:
     def_signal [$signal_definition, ...]
     #{run-and-kill-signals!}(racketset.set($signal_definition.id,...,...),fun (): $body)'
  
expr.macro 'esterel:
              $body':
  '#{esterel/proc}(0, fun (): $body)'

operator ¿ x:
  ~stronger_than |||
  #{present?}(x)

expr.macro '$left ||| $right':
   '#{par/proc}(PairList(fun (): $left, fun(): $right))'

fun
| emit(s): kernel_emit(s)
| emit(s,v): kernel_emit(s,v)

fun react(r, ~emit: signals = []):
  // the for loop here converts an equal
  // hash into an equal-always hash in
  // order to cooperate better with Rhombus
  def rkt_signals = PairList(&signals).map(fun | ([signal, val]): Pair.cons(signal, val)
                                               | (signal): signal)
  for Map:
    each (k,v): #{react!}(r, ~emit: rkt_signals) :~ Map
    values(k,v)

expr.macro 'with_trap $t:
              $body':
  '#{with-trap/proc}(#'$t,fun ($t):
                            $body)'

expr.macro 'par
            | $body
            | ...':
  '#{par/proc}(PairList(&[fun (): $body, ...]))'

expr.macro 'pause':
  'kernel_pause()'

fun exit_trap(t):
  #{exit-trap}(t)

fun signal_name(s):
  #{signal-name}(s)

fun signal_index(s):
  #{signal-index}(s)

fun is_esterel(v):
  #{esterel?}(v)

fun in_esterel():
  #{in-esterel?}()

fun is_signal(v):
  #{signal?}(v)

fun is_present(s, ~pre: pre = 0):
  #{present?}(s, ~pre: pre)

fun signal_value(s, ~pre: n = 0, ~can: can = Set()):
  #{signal-value}(s, ~pre: n, ~can: racketset.#{list->set}(PairList(&Set.to_list(can))))

fun debug_when_must(stx):
  #{debug-when-must}(stx)

fun signal_combine(s):
  #{signal-combine}(s)

expr.macro 'suspend:
              $body_expr
              ~when $when_expr':
    'pkernel.suspend($body_expr, $when_expr)'
    
fun is_trap(v):
  #{trap?}(v)
